\chapter{Zusammenfassung \& Reflexion}

Sortierte Sequenzen stellen eine mächtige Datenstruktur dar, insbesondere, wenn sie mit (a,b)-Bäumen als Navigationsstruktur umgesetzt werden. Die Funktionsweise von Operationen wie Finden, Einfügen und Entfernen wurde in dieser Arbeit erörtert. Die wohl wichtigste Erkenntnis stellt dar, dass diese Operationen in logarithmischer Zeit ausgeführt werden können. Die Laufzeit der Operationen entwickelt sich logarithmisch in Abhängigkeit von der Anzahl  der Elemente in der sortierten Sequenz. Diese Eigenschaft konnte auch durch die Testreihe an meiner eigenen Implementierung von (a,b)-Bäumen bestätigt werden.
\par
Besagte Implementierung führte ich in Python durch, was sich aufgrund der umkomplizierten Natur der Datentypenverwaltung in Python als richtige Entscheidung herausstellte. Gerne hätte ich C benutzt, da es schneller ist. Die Probleme und offenen Fragen bei der Umsetzung erwiesen sich jedoch als zu groß und zu umfrangreich für meinen Kenntnisstand.
\par
Ich bedauere sehr, dass die Implementierung von \texttt{bulkInsert} nicht erfolgreich war, und auch \texttt{split} womöglich fehlerhaft ist. Deshalb werde ich weiterhin an der Lösung arbeiten und die Früchte meiner Arbeit auf GitHub veröffentlichen. Die Implementierung bereitete mir viel Freude und es wäre sehr lohnenswert, alles in einen funktionstüchtigen Zustand umzusetzen.
\par
Während der Bearbeitung des Themas fiel mir auf, dass verhältnismäßig wenig Material über sortierte Sequenzen und (a,b)-Bäume existiert. Das Buch \textit{"`Sequential and Parallel Algorithms and Data Structures - The Basic Toolbox"'} \cite{Sanders:19} bietet den umfangreichsten Einblick in Aufbau und Funktionsweise von (a,b)-Bäumen und lieferte somit den Großteil der Informationen für diese Arbeit.
\par
Abschließend stelle ich fest, dass es sehr interessant war, sich über (a,b)-Bäume und sortierte Sequenzen zu informieren. Insbesondere hervorheben möchte ich, dass es trotz der Probleme mit \texttt{bulkInsert} eine äußerst gute Erfahrung war, die in der Theorie kennengelernte Technik in ein echtes Programm umzusetzen. Die stellte sich als sehr unterschiedlich zu früheren Projekten heraus, da ich sämtliche Fehler durch eigenes Testen beheben musste, anstatt im Internet nach eine Lösung zu suchen. Das Beheben von Fehlern wurde so zu einer ausgesprochen belohnenden Erfahrung.
